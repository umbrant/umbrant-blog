<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	<head>
		<title>
			
			Lottery and stride scheduling : umbrant
			
		</title>

		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<link rel="icon" type="image/ico" href="/favicon.ico"/>

		
		<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/UmbrantBlog" title="umbrant"/>
		

		
		<link href="/media/css/style.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="/media/css/pygments.css" rel="stylesheet" type="text/css" media="screen" />
		<link href='http://fonts.googleapis.com/css?family=Quattrocento|Droid+Sans|Droid+Sans+Mono' rel='stylesheet' type='text/css'/>
		
		
		

		
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script type="text/javascript" src="/media/js/umbrant.js"></script>
		
		<script type="text/javascript">

  			var _gaq = _gaq || [];
  			_gaq.push(['_setAccount', 'UA-4601421-1']);
  			_gaq.push(['_trackPageview']);

  			(function() {
    		 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    		 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    		 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  			 })();

		 </script>
		 
		 
	 </head>

	 <body>
		 <div id="wrapper">
			<div id="page">
				<div id="page-bgtop">
					<div id="page-bgbtm">
						<div id="content">

							

	


	

		<div class="post single">
			<h2 class="title"><a href="">Lottery and stride scheduling</a></h2>
			
			<p class="meta"><span class="date">July 17, 2011</span></p>
			
			<div class="entry">
			

			<!-- Hyde::Article::Begin -->

<!-- Hyde::Excerpt::Begin -->

<p>Today is a shorter post than previous topics, since I didn&#8217;t want to lump the last paper (Paxos, ick) in with these. I&#8217;m covering lottery and stride scheduling, two very related approaches to doing efficient proportional-share scheduling. I believe this is the canonical way of doing things, since mClock (by Gulati et al., presented at <span class="caps">OSDI</span> 2010) used stride scheduling successfully to schedule disk I/O in a&nbsp;hypervisor.</p>
<ul>
<li><span class="dquo">&#8220;</span>Lottery Scheduling: Flexible Proportional-Share Resource Management&#8221;, Waldspurger and Weihl,&nbsp;1994</li>
<li><span class="dquo">&#8220;</span>Stride Scheduling: Deterministic Proportional-Share Resource Management&#8221;, Waldspurger and Weihl,&nbsp;1995</li>
</ul>
<!-- Hyde::Excerpt::End -->

<h3>Background</h3>
<p>The basic problem for proportional-share scheduling is, given a set of processes that have been assigned relative <em>weights</em> (e.g. 3:2:1), schedule the processes with some kind of quantum such that they all get their assigned proportion of <span class="caps">CPU</span> time (e.g. 1/2rd, 1/3rd, 1/6th). A naive way of doing this is to simply schedule each process for <em>weight</em> number of scheduling quantums, but this penalizes processes that do not use their entire allocation (for instance, if they block on I/O early) and results in unfairness at small timescales (think of a 100:1:1 weighting). It&#8217;s also desired that scheduling is responsive to changes in&nbsp;priorities.</p>
<p>These are some of the practical problems that any good proportional share scheduler has to&nbsp;solve.</p>
<h3>Lottery&nbsp;Scheduling</h3>
<p>Waldspurger and Weihl&#8217;s first approach is a probabilistically fair one. Processes are assigned a number of <em>tickets</em> based on their relative weight (bigger weight=more tickets), and the scheduler holds a <em>lottery</em> each scheduling quantum (choosing a random ticket) where the winner gets scheduled. A quantum is small unit of time, in this case 10ms, which is the smallest unit that the scheduler will assign to a process. This means processes with more tickets get scheduled more often, and over time the actual scheduling should probabilistically approaches the desired relative weighting between the processes with standard deviation proportional to <code>sqrt(n)</code>.</p>
<p>This can be implemented by logically storing the number of tickets of each processes in an array, and keeping a running sum of tickets as one traverses the array, advancing until the winning ticket is found. This is an <code>O(n)</code> operation, but sorting the array in descending order with insertion sort (or, as the authors do it, the &#8220;move to front&#8221; heuristic) can make this a lot faster. For large n, it&#8217;s better to take an approach with a tree and binary search toward the winning leaf node&nbsp;process.</p>
<p>If a process ends early or runs over its quantum, the size of its ticket pool gets adjusted until it gets scheduled again with a <em>compensation ticket</em>. This compensation ticket is valued at <code>(1/f)*num_tickets</code>, where <code>f</code> is the fraction of its allocated time that it actually used. This will increase or decrease its likelihood of getting scheduled&nbsp;appropriately.</p>
<p>It&#8217;s relatively straightforward to build a hierarchical scheduling system via what the authors term <em>ticket currencies</em>: different types of tickets that are backed by other tickets. In this way, groups of processes can be weighted based on one currency, and then the members of each group weighted based on another currency. This is basically just a nice management feature; in the end, everything gets translated back into the base&nbsp;currency.</p>
<p>They also have this idea of letting clients pass their ticket allocations off to a server, which is kind of cool when combined with a microkernel where everything is a server. It means you can give tickets only to clients, and make it so all server requests have to be paid for with a ticket allocation. Then, tickets accurately capture all work done in the system on behalf of a client process. My random&nbsp;idea.</p>
<p>They also have a similar idea with a priority inheritance scheme of sorts for locks, where all the tickets of processes waiting on a lock are passed to the process currently holding the lock. They also test lottery scheduling lock acquisition, which seems of somewhat lower utility to me. I don&#8217;t know how often I would ever want to use this, as a&nbsp;programmer.</p>
<p>Lottery scheduling isn&#8217;t really that responsive to dynamic changes, since it takes time to converge. Its probabilistic nature also means that it can&#8217;t really give predictable performance, meaning that it might be decently suited for &#8220;average throughput&#8221; schedulers, but probably sucks for interactive uses where you want <span class="caps">SLA</span>-like performance&nbsp;guarantees.</p>
<h3>Stride&nbsp;Scheduling</h3>
<p>The follow up paper the year after solves many of the problems with lottery scheduling, by introducing the concept of <em>stride scheduling</em>, which has all the benefits of lottery scheduling while also being deterministic, responsive to dynamic priorities, and better error properties. This is slightly different from how it&#8217;s presented in the paper, but I think it makes more&nbsp;sense.</p>
<p>This is something most easily explained visually, but the basic idea is the concept of <em>virtual time</em>, where each process has a clock that ticks at a different rate depending on its priority. High priority clocks tick slowly, while low priority clocks tick quickly. The rate at which a clock ticks is called its <em>stride</em>. The scheduler makes decisions by finding the clock with the oldest time, scheduling the corresponding process, and then advancing the clock by the clock&#8217;s stride. This is implemented simply by keeping the clocks in ascending sorted order via a heap, insertion sort, or something like&nbsp;that.</p>
<p>Fractional quantums are handled via a multiplicative compensation factor: simply multiplying the stride by the fraction of the quantum used, before advancing the local&nbsp;clock.</p>
<p>There is also the concept of <em>global virtual time</em> that advances at the rate of the slowest possible tick (<code>~1/sum(tickets)</code>). This is used to calculate a compensation factor, <code>remain</code>, used to compensate a process for time spent waiting when there is a dynamic change. <code>remain</code> is the amount of virtual time until a process would next be scheduled, i.e. the difference between the global virtual time and the local virtual time. When the process re-enters the system, its local time is set to <code>global_time+remain</code>. In this way, if the process waited to be allocated before leaving (<code>remain&amp;lt;stride</code>) it gets scheduled sooner. The opposite happens if the process previously got an early&nbsp;allocation.</p>
<p>Since the stride and <code>remain</code> are both related to the size of the ticket allocation, in the case of a dynamic change, the stride is recomputed and used to scale <code>remain</code> appropriately to immediate reflect the new&nbsp;allocation. </p>
<p>This is extremely predictable since scheduling is deterministic, and processes are guaranteed to be scheduled at least once every complete cycle of virtual time (where a cycle is the slowest stride). This is a major boon for responsiveness since we no longer have to wait for probabilities to converge. Glancing at the evaluation section, I see major improvements to predictability, responsiveness to priority changes, and accuracy. The same ideas of ticket currencies and ticket passing also apply to stride&nbsp;scheduling.</p>
<!-- Hyde::Article::End -->

			
			</div>
		</div>


	
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'umbrant'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
    var disqus_identifier = '/blog/2011/lottery_stride_scheduling.html';
    var disqus_url = 'http://www.umbrant.com/blog/2011/lottery_stride_scheduling.html';
    //var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




						</div>
						<!-- end #content -->

						<div id="sidebar">
	<div id="logo">
		<h1><a href="/">umbrant</a></h1>
	</div>
	<div>
		<p>My name is Andrew Wang. I'm a CS PhD student at UC Berkeley working in distributed systems.</p>
	</div>
	<div id="menu">
		<ul>
			<li><a href="/">Home</a></li>
			<li><a href="/about.html">About</a></li>
			<li><a href="/research.html">Research</a></li>
			<li><a href="/contact.html">Contact</a></li>
		</ul>
	</div>
	<ul>
		<li>
		<h2>Recent Posts</h2>
		<ul>
			
				
			
				

					
					
						
						<li><a href="/blog/2011/warehouse_scale_computing_summary.html">Paper review: Warehouse-Scale Computing: Entering the Teenage Decade</a></li>
						
					
						
						<li><a href="/blog/2011/lottery_stride_scheduling.html">Lottery and stride scheduling</a></li>
						
					
						
						<li><a href="/blog/2011/concurrency.html">Concurrency review</a></li>
						
					
						
						<li><a href="/blog/2011/virtual_memory.html">Virtual memory review</a></li>
						
					
						
						<li><a href="/blog/2011/android_the_good_and_bad.html">Android: the Good, the Bad, and the Ugly</a></li>
						
					
						
						<li><a href="/blog/2011/external_sorting.html">External sorting of large datasets</a></li>
						
					
				
			
				
			
				
			
				
			
		</ul>
		</li>
		<li>
		<h2>Archive</h2>
		<ul>
			
			
			
			
				
				
				
				
				
				
				<li><a href="/blog/2011/2011.html">2011</a></li>
				
				
				
				
			
			
			
			
			
			
			
			
		</ul>
		</li>
	</ul>
</div>

						<!-- end #sidebar -->

									<div id="footer">
				<p>Copyright &copy; Andrew Wang, umbrant.com</p>
				<p>Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a></p>
				<br/>
				<p><a href="http://feeds.feedburner.com/UmbrantBlog"><img src="/media/images/feed-icon-14x14.png" alt="feed"/>&#160; Subscribe to my feed</a></p>
			</div>

						<!-- end #footer -->

					</div>
				</div>
			</div>
			<!-- end #page -->
		</div>
	 </body>
 </html>

 