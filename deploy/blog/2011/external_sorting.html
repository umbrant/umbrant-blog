<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	<head>
		<title>
			
			External sorting of large datasets : umbrant
			
		</title>

		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<link rel="icon" type="image/ico" href="/favicon.ico"/>

		
		<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/UmbrantBlog" title="umbrant"/>
		

		
		<link href="/media/css/style.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="/media/css/pygments.css" rel="stylesheet" type="text/css" media="screen" />
		<link href='http://fonts.googleapis.com/css?family=Quattrocento|Droid+Sans|Droid+Sans+Mono' rel='stylesheet' type='text/css'/>
		
		
		

		
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script type="text/javascript" src="/media/js/umbrant.js"></script>
		
		<script type="text/javascript">

  			var _gaq = _gaq || [];
  			_gaq.push(['_setAccount', 'UA-4601421-1']);
  			_gaq.push(['_trackPageview']);

  			(function() {
    		 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    		 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    		 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  			 })();

		 </script>
		 
		 
	 </head>

	 <body>
		 <div id="wrapper">
			<div id="page">
				<div id="page-bgtop">
					<div id="page-bgbtm">
						<div id="content">

							

	


	

		<div class="post single">
			<h2 class="title"><a href="">External sorting of large datasets</a></h2>
			
			<p class="meta"><span class="date">April 15, 2011</span></p>
			
			<div class="entry">
			

			<!-- Hyde::Article::Begin -->

<!-- Hyde::Excerpt::Begin -->

<p>This is a common interview question: how do you sort data that is bigger than memory? "Big data" in the range of tera or petabytes can now almost be considered the norm (think of Google saving every search, click, and ad impression ever), so this manifests in reality as well. This is also a canonical problem in the database world, where it is referred to as an "external&nbsp;sort".</p>
<p>Your mind should immediately turn to divide and conquer algorithms, namely merge sort. Write out intermediate merged output to disk, and read it back in lazily for the next round. I decided this would be a fun implementation and optimization exercise to do in C. There will probably be a follow-up post, since there are lots of optimizations I haven't yet&nbsp;implemented.</p>
<!-- Hyde::Excerpt::End -->

<h3>Introduction</h3>
<p>Guido van Rossum (the creator of Python) did this a while ago for the rather smaller (and simpler) case of <a href="http://neopythonic.blogspot.com/2008/10/sorting-million-32-bit-integers-in-2mb.html">sorting a million 32-bit integers in 2MB of RAM</a>. I took the same approach of a merge sort that writes intermediate runs out to files on disk, buffering file I/O to improve performance. However, since I'm targeting file sizes that are actually larger than RAM (e.g. a couple gigabytes), I need to do more complicated&nbsp;things.</p>
<p>The <a href="http://en.wikipedia.org/wiki/Merge_sort">basic merge sort</a> you learn in CS 101 recurses down to the base case of runs of just 1 element, which are progressively merged together in pairs in a logarithmic fashion (arriving at the ultimate O(n*log n) time complexity). This is inefficient for large datasets, because the merging rate is too low. If you're sorting a 1GB file of 32-bit integers, the first round of merging would generate <code>(1GB/sizeof(int)/2) = (2^30/2^2/2) = 2^27</code> 8-byte files, which is just too many files. This also leads to the second core problem: small disk I/Os are highly inefficient, since they result in expensive disk seeks. Writing a bunch of 8-byte (or even 8-kilobyte) files effectively randomizes your access pattern, and will choke your throughput. To avoid bad seeks, reads and writes need to be done at about the size of the disk's buffer (about 16MB these&nbsp;days).</p>
<p>All of my code is also <a href="https://github.com/umbrant/extsort">available on github</a> if you want to follow along, this post is based more-or-less on the <a href="https://github.com/umbrant/extsort/tree/3ce53516063bff05570736c412eed032b803ea15">initial commit</a>.</p>
<h3>Basic&nbsp;Approach</h3>
<p>So our goal is to reduce the number of files written by the first merge step, and also write these files in much bigger chunks. This can be accomplished by increasing the quantum for merging, and doing n-way instead of 2-way&nbsp;merging.</p>
<p>I increased the merge quantum by sorting each page (4KB) of initial input with quicksort. This way, even with just 2-way merging, the first round for our 1GB of integers only generates <code>(1GB/page_size/2) = (2^30/2^12/2)</code> = 2^18 intermediate files, which is a lot better than 2^27, but still too large (a quarter million files is a&nbsp;lot). </p>
<p>N-way merging merges more (many more) than two runs together at once, and is basically the same algorithm as 2-way merging. This finally reduces the level of fan out to manageable levels, and means that the size of the output runs is much larger, meaning that disk I/O can be more easily batched into large 16MB chunks. With 64-way merging we finally get down to <code>(2^18/2^6) = 2^12</code>, or 4096 intermediate files, which is a pleasant&nbsp;number.</p>
<p>A further necessary improvement is to incrementally pull large runs off disk (required for later merge steps, when the runs are too large to all fit into memory). I do this at the same granularity as my other I/O operations: 16MB. Currently, this decides the degree of fan out as well, since I pack as many 16MB buffers into memory as I'm allowed, and n-way merge across all of them. This could be a problem if oodles and oodles of memory are allocated to the sort (since n gets large), but my computer with 4GB of RAM can only hold 256 runs, which isn't that&nbsp;many.</p>
<h3>Miscellaneous&nbsp;notes</h3>
<p>There are a few other miscellaneous notes. I ran into the per-process fd limit when doing large merges, so files have to be closed and reopened at the correct offset. I also parallelize the initial quicksorting of pages with a simple worker pool, which really helps speed up the first layer of merging. 
My quicksort also reduces recursion depth by bubblesorting for runs smaller than 5, which is okay since bubblesort is efficient on tiny sets (worst case 6 compares, 6 swaps, compare that to insertion sort). This might or might not increase performance, but it's fun. Finally, even if 256 buffers can fit into memory, one buffer must always be reserved to be an output buffer (meaning you can do at most a 255-way merge). There's also some <code>O(n)</code> memory overhead outside of just storing the data buffers, which you need to be aware of if your memory bound is especially&nbsp;tight.</p>
<h3>Benchmarking</h3>
<p>Enough discussion, onto the numbers! This is a situation where I feel like building an autotuner, since my envisioned final version will have a number of knobs to tweak (a future project I suppose). Right now, the two knobs I have to play with are the size of the overall buffer, and the size of I/O&nbsp;buffers. </p>
<p>I took two sets of numbers. The first set was taken on my laptop, which is a Intel Core i7-620M supporting 4 hyperthreads, 4GB of RAM, and a 7200 RPM disk. The second set was taken on my desktop, an AMD Phenom II X4 965 Black Edition supporting 4 hardware threads, 4GB of RAM, and an 60GB OCZ Vertex 2 SSD. The SSD should help for the smaller I/O buffer sizes, but sequential access shouldn't be too far&nbsp;apart.</p>
<!-- Hyde::Article::End -->

			
			</div>
		</div>


	
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'umbrant'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
    var disqus_identifier = '/blog/2011/external_sorting.html';
    var disqus_url = 'http://www.umbrant.com/blog/2011/external_sorting.html';
    //var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




						</div>
						<!-- end #content -->

						<div id="sidebar">
	<div id="logo">
		<h1><a href="/">umbrant</a></h1>
	</div>
	<div>
		<p>My name is Andrew Wang. I'm a computer science PhD student at UC Berkeley in distributed systems.</p>
	</div>
	<div id="menu">
		<ul>
			<li><a href="/">Home</a></li>
			<li><a href="/about.html">About</a></li>
			<li><a href="/research.html">Research</a></li>
			<li><a href="/contact.html">Contact</a></li>
		</ul>
	</div>
	<ul>
		<li>
		<h2>Recent Posts</h2>
		<ul>
			
				
			
				

					
					
						
					
						
						<li><a href="/blog/2011/album_first_impressions_pt_1.html">Album first impressions pt. 1</a></li>
						
					
						
						<li><a href="/blog/2011/static_hosting_on_s3.html">Static website hosting on Amazon S3</a></li>
						
					
						
						<li><a href="/blog/2011/hello_world.html">Hello world!</a></li>
						
					
						
					
				
			
				
			
		</ul>
		</li>
		<li>
		<h2>Archive</h2>
		<ul>
			
			
			
			
				
					
					<li><a href="/blog/2011/2011.html">2011</a></li>
					
				
					
				
			
			
			
			
		</ul>
		</li>
	</ul>
</div>

						<!-- end #sidebar -->

									<div id="footer">
				<p>Copyright &copy; Andrew Wang, umbrant.com</p>
				<p>Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a></p>
				<br/>
				<p><a href="http://feeds.feedburner.com/UmbrantBlog"><img src="/media/images/feed-icon-14x14.png" alt="feed"/>&#160; Subscribe to my feed</a></p>
			</div>

						<!-- end #footer -->

					</div>
				</div>
			</div>
			<!-- end #page -->
		</div>
	 </body>
 </html>

 