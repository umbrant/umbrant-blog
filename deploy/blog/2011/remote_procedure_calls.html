<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	<head>
		<title>
			
			Remote Procedure Call review : umbrant
			
		</title>

		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<link rel="icon" type="image/ico" href="/favicon.ico"/>

		
		<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/UmbrantBlog" title="umbrant"/>
		

		
		<link href="/media/css/style.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="/media/css/pygments.css" rel="stylesheet" type="text/css" media="screen" />
		<link href='http://fonts.googleapis.com/css?family=Quattrocento|Droid+Sans|Droid+Sans+Mono' rel='stylesheet' type='text/css'/>
		
		
		

		
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script type="text/javascript" src="/media/js/umbrant.js"></script>
		
		<script type="text/javascript">

  			var _gaq = _gaq || [];
  			_gaq.push(['_setAccount', 'UA-4601421-1']);
  			_gaq.push(['_trackPageview']);

  			(function() {
    		 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    		 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    		 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  			 })();

		 </script>
		 
		 
	 </head>

	 <body>
		 <div id="wrapper">
			<div id="page">
				<div id="page-bgtop">
					<div id="page-bgbtm">
						<div id="content">

							

	


	

		<div class="post single">
			<h2 class="title"><a href="">Remote Procedure Call review</a></h2>
			
			<p class="meta"><span class="date">June 11, 1911</span></p>
			
			<div class="entry">
			

			<!-- Hyde::Article::Begin -->

<!-- Hyde::Excerpt::Begin -->

<p>Part two in my self-study on important papers in systems. This time, I&#8217;m covering remote procedure calls (<span class="caps">RPC</span>), which are effective ways of packaging up a function call, sending it to a remote machine to be executed, and then getting the result. The idea throughout all of these schemes is to make the difference between remote and local calls as minimal as possible, and almost transparent from a programming perspective. Material is derived from three&nbsp;papers:</p>
<ul>
<li><em>Implementing Remote Procedure Calls</em> by Birrell and Nelson&nbsp;(1984)</li>
<li><em><span class="caps">RPC</span> in the x-Kernel: Evaluating New Design Techniques</em> by Hutchinson et al.&nbsp;(1989)</li>
<li><em>Lightweight Remote Procedure Call</em> by Bershad et al.&nbsp;(1990)</li>
</ul>
<!-- Hyde::Excerpt::End -->

<h3>Background&nbsp;Review</h3>
<p>Some people consider <a href="http://en.wikipedia.org/wiki/Memory_segmentation">segmentation</a> to be the most natural way of structuring a program. Most programs are basically a collection of libraries (something really true in modern software engineering). In a segmented virtual memory system, each distinct library is placed in its own separate segment such that it has its own address space. They&#8217;re still all mapped unto the same flat physical memory address space, but through per-segment base and offset&nbsp;addresses.</p>
<p>This isn&#8217;t actually used much in modern operating systems for reasons I&#8217;m not entirely aware of (I&#8217;d guess simplicity and performance), but it&#8217;s a pleasingly abstract and indirect way of organizing a program (a hallmark of&nbsp;Multics).</p>
<h3>Virtual Memory, Processes, and Sharing in&nbsp;<span class="caps">MULTICS</span></h3>
<p>Multics structured its programs in terms of segments, which could be read/write/execute protected. Segmentation is great for doing memory protection (and something that only recently reemerged as the <a href="http://en.wikipedia.org/wiki/NX_bit"><span class="caps">NX</span> bit</a> for flat memory models), since it&#8217;s easy to do a compare on any <code>(base+offset)</code> calculation and see if it falls into a protected range. Segments can still of course be paged, and segmentation and paging are complementary: segmentation for protection, and paging for working set&nbsp;management.</p>
<p>Addressing in Multics is done in terms of a <em>generalized address</em>: <code>(segment num + word num)</code>. The segment number of the currently executing segment is stored in the <em>procedure base register</em>, so most instructions just need to specify a word number. Indirect addressing (i.e. referencing an address stored at an address) is done with a pair of instructions to have enough bits: one for the segment number, one for the word&nbsp;number.</p>
<p>A <em>descriptor table</em> is kept of all the segments in a program to map them to hardware addresses. This table maps seg nums to a physical address, and then adds the word num as the offset. This is similar to a page table: virtual to physical address translation. A pointer to the descriptor table is saved as part of the context information of the&nbsp;process.</p>
<p>Now for the complicated bits: dynamic linking. Clearly, we don&#8217;t want each program to have to have its own copy of shared segments (say, libc), and we want some abstraction so we aren&#8217;t hardcoding word numbers into our program. This also needs to work for segments linking to other segments which link to other segments, etc., so it gets a little hairy. We also want this to be reasonably fast, e.g. don&#8217;t do multiple memory accesses for every dynamically linked call, at least after the first time. In list&nbsp;form:</p>
<ul>
<li>Dynamically linked accesses are specially marked in the program&nbsp;text</li>
<li>Dynamically linked segments are present at a well-know <em>path name</em>, e.g. in Linux <code>/usr/lib/ld-linux.so.2</code>, that the system can search for and find (see&nbsp;LD_LIBRARY_PATH).</li>
<li>Each segments presents a <em>symbol table</em>, which defines the call-in points for the segment (static vars, functions,&nbsp;etc)</li>
<li>Initially, all calls to an external function are to an indirect reference stored as <em>link data</em> in a per-segment <em>linkage table</em>. This table is initially set to trap to an <span class="caps">OS</span> lookup&nbsp;function. </li>
<li>A <em>linkage pointer</em> to the <em>linkage table</em> is maintained to switch around the table as context changes to different&nbsp;segments.</li>
<li>On the first reference, the <span class="caps">OS</span> lookup function finds the file of the external segment, examines its symbol table, and then <em>links</em> the two segments by updating the link data in the linkage table. Future references use that indirect address to go straight to the external&nbsp;segment.</li>
<li>A further complication enters when switching the linkage pointers between linked segments. To determine the new value for the linkage pointer, the calling procedure actually calls into the new segment&#8217;s linkage table, which has special instructions to fixup the linkage pointer and then call the called procedure.<ul>
<li>Thus: Caller -&gt; Caller&#8217;s linkage table ~&gt; Callee&#8217;s linkage table ~&gt;&nbsp;Callee</li>
<li>This is direct -&gt; indirect -&gt; indirect, plus a fixup, seems&nbsp;expensive&#8230;</li>
</ul>
</li>
</ul>
<p>This really isn&#8217;t that different from how Linux does it, the basic idea of &#8220;keep a well-known table that fixes itself on the first reference&#8221; is a winner. I feel like there are a lot of memory accesses required to traverse all these layers of indirection, since you are calling through multiple layers of indirect addressing, each of which is a pair of&nbsp;instructions.</p>
<h3>The Multics Virtual Memory: Concepts and&nbsp;Design</h3>
<p>It&#8217;s weird to hear that back in the days of yore, files could not be easily loaded as program text, and the idea of virtual memory for protection, abstraction, and programmer benefit was a new idea. Users were just allocated a range of memory, or <em>core image</em>, with no sharing between users; if you wanted to work on a &#8220;shared file&#8221;, that meant doing I/O to copy it into your range, and then another I/O to put it back into the filesystem. Each user&#8217;s core image was also an unstructured jumble of instructions and data, which makes system-level sharing and memory protection basically&nbsp;impossible.</p>
<p>These two goals motivated the design of virtual memory in Multics: sharing and protection. This led to the <em>segmentation</em>, where each segment appears as a flat, linear namespace to the user program, with read/write/execute/append access rights attached as metadata to the&nbsp;segment.</p>
<p>Segments are also paged to ease the allocation problem and to support large segments. <em>Descriptor segments</em> (aka descriptor tables) are also paged for good reason, meaning 4 memory lookups to access a memory location, going through two page tables (one for the descriptor, one for the segment). TLBs work here, but it still sounds slow. Page tables are also a static size, not a&nbsp;tree.</p>
<p>This paper is a decent overview of Multics, probably would have made sense to read it before the dynamic linking&nbsp;one.</p>
<!-- Hyde::Article::End -->

			
			</div>
		</div>


	
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'umbrant'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
    var disqus_identifier = '/blog/2011/remote_procedure_calls.html';
    var disqus_url = 'http://www.umbrant.com/blog/2011/remote_procedure_calls.html';
    //var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




						</div>
						<!-- end #content -->

						<div id="sidebar">
	<div id="logo">
		<h1><a href="/">umbrant</a></h1>
	</div>
	<div>
		<p>My name is Andrew Wang. I'm a CS PhD student at UC Berkeley working in distributed systems.</p>
	</div>
	<div id="menu">
		<ul>
			<li><a href="/">Home</a></li>
			<li><a href="/about.html">About</a></li>
			<li><a href="/research.html">Research</a></li>
			<li><a href="/contact.html">Contact</a></li>
		</ul>
	</div>
	<ul>
		<li>
		<h2>Recent Posts</h2>
		<ul>
			
				
			
				

					
					
						
						<li><a href="/blog/2011/performance_modeling_and_analysis_of_flash_review.html">Paper review: Performance Modeling and Analysis of Flash-based Storage Devices</a></li>
						
					
						
						<li><a href="/blog/2011/data-level_parallelism_review.html">Paper review: Data-Level Parallelism in Vector, SIMD, and GPU Architectures</a></li>
						
					
						
						<li><a href="/blog/2011/amdahls_law_review.html">Paper review: Amdahl&#39;s Law in the Multicore Era</a></li>
						
					
						
						<li><a href="/blog/2011/datacenter_as_a_computer_3_4_7_review.html">Paper review: The Datacenter as a Computer Ch. 3, 4, 7</a></li>
						
					
						
						<li><a href="/blog/2011/warehouse_scale_computing_summary.html">Paper review: Warehouse-Scale Computing: Entering the Teenage Decade</a></li>
						
					
						
						<li><a href="/blog/2011/lottery_stride_scheduling.html">Lottery and stride scheduling</a></li>
						
					
				
			
				
			
				
			
				
			
		</ul>
		</li>
		<li>
		<h2>Archive</h2>
		<ul>
			
			
			
			
				
				
				
				
				
				
				<li><a href="/blog/2011/2011.html">2011</a></li>
				
				
				
				
			
			
			
			
			
			
			
			
		</ul>
		</li>
	</ul>
</div>

						<!-- end #sidebar -->

									<div id="footer">
				<p>Copyright &copy; Andrew Wang, umbrant.com</p>
				<p>Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a></p>
				<br/>
				<p><a href="http://feeds.feedburner.com/UmbrantBlog"><img src="/media/images/feed-icon-14x14.png" alt="feed"/>&#160; Subscribe to my feed</a></p>
			</div>

						<!-- end #footer -->

					</div>
				</div>
			</div>
			<!-- end #page -->
		</div>
	 </body>
 </html>

 