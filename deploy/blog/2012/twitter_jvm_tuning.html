<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

	<head>
		<title>
			
			JVM Performance Tuning (notes) : umbrant
			
		</title>

		<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
		<link rel="icon" type="image/ico" href="/favicon.ico"/>

		
		<link rel="alternate" type="application/atom+xml" href="http://feeds.feedburner.com/UmbrantBlog" title="umbrant"/>
		

		
		<link href="/media/css/style.css" rel="stylesheet" type="text/css" media="screen" />
		<link href="/media/css/pygments.css" rel="stylesheet" type="text/css" media="screen" />
		<link href='http://fonts.googleapis.com/css?family=Quattrocento|Droid+Sans|Droid+Sans+Mono' rel='stylesheet' type='text/css'/>
		
		
		

		
		<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script type="text/javascript" src="/media/js/umbrant.js"></script>
		
		<script type="text/javascript">

  			var _gaq = _gaq || [];
  			_gaq.push(['_setAccount', 'UA-4601421-1']);
  			_gaq.push(['_trackPageview']);

  			(function() {
    		 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    		 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    		 var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  			 })();

		 </script>
		 
		 
	 </head>

	 <body>
		 <div id="wrapper">
			<div id="page">
				<div id="page-bgtop">
					<div id="page-bgbtm">
						<div id="content">

							

	


	

		<div class="post single">
			<h2 class="title"><a href="">JVM Performance Tuning (notes)</a></h2>
			
			<p class="meta"><span class="date">January 18, 2012</span></p>
			
			<div class="entry">
			

			<!-- Hyde::Article::Begin -->

<!-- Hyde::Excerpt::Begin -->

<p>A presentation by Attila Szegedi titled <a href="http://www.infoq.com/presentations/JVM-Performance-Tuning-twitter">&#8220;Everything I Ever Learned about <span class="caps">JVM</span> Performance Tuning @twitter&#8221;</a> has been floating around for a few months. I&#8217;ve restructured much of the content into a set of notes. This covers the basics of memory allocation and garbage collection in Java, the different garbage collectors available in HotSpot and how they can be tuned, and finally some anecdotes from Attila&#8217;s experiences at&nbsp;Twitter.</p>
<p>I&#8217;m still fuzzy on some things, so it&#8217;s not ground truth. If more experienced people weigh in, I&#8217;ll fix things up. The very informative hour-long presentation is still highly&nbsp;recommended.</p>
<!-- Hyde::Excerpt::End -->

<h3>The Price of an&nbsp;Object</h3>
<p>Java, as an object-oriented language, naturally results in the creation of a lot of objects. This is one of the things you give up as opposed to a language like C; even basic data-wrapper objects are much heavier weight than structs. The minimal object is <strong>24 bytes</strong>: 16B of object overhead, and 8B for the pointer to that object. This includes arrays, which also incur 24B for an empty array, 4B for the size of the array, then per-item costs after that (you only need one&nbsp;pointer).</p>
<p>Primitive types don&#8217;t need require the 16B of object overhead, and are thus can be a much more compact representation. However, beware <em>autoboxing</em>: many provided data structures will automatically convert your nice compact <code>int</code> into a big fat <code>Integer</code>. Using plain old arrays of primitive types can be the best choice. It&#8217;s definitely better than allocating lots of tiny objects which will end up being substantially&nbsp;overhead.</p>
<p>As a side note not mentioned by Attila, also beware the use of the Java <code>String</code> class, since it can <strong>double</strong> your in-memory storage costs. Java internally uses <span class="caps">UTF</span>-16 for its strings, which is a 2-byte character encoding. Compare this to the more common <span class="caps">UTF</span>-8 or <span class="caps">ASCII</span> encodings, which are both 1-byte. This glosses over the details (<span class="caps">UTF</span>-16 and <span class="caps">UTF</span>-8 are variable-length encodings, and can be up to 4 bytes per character), but this doubling holds true for the common&nbsp;case.</p>
<p>There are two more twists here. First, Java pads out all objects to the nearest 8-byte boundary, which fattens up objects a bit more. This isn&#8217;t all bad though, since it aids the second twist: pointer compression. Beneath <span class="caps">32GB</span> of heap, the <span class="caps">JVM</span> will actually only use 4B per pointer instead of 8B. Why is 4B enough for <span class="caps">32GB</span>? Since everything is padded out to 8B, the pointer can just be left shifted by three bits before doing the normal byte addressing. However, this means if you want a heap bigger than <span class="caps">32GB</span>, you need to jump up a lot; Attila says&nbsp;<span class="caps">48GB</span>.</p>
<h3><span class="caps">JVM</span> Memory&nbsp;Management</h3>
<p>The <span class="caps">JVM</span> heap is split up into two <em>generations</em> which are garbage collected at different rates. All objects are allocated in the <em>young generation</em>; more specifically, they are allocated within <em>Eden</em> in the young generation. As objects survive <span class="caps">GC</span> rounds, they get copied to the two successive <em>survivor</em> regions within the young generation, before ultimately being <em>tenured</em> to the <em>old generation</em>, which gets <span class="caps">GC</span>&#8217;d less frequently than the young&nbsp;generation.</p>
<p>This means that Java optimizes for the common case of short-lived trash that can get quickly collected in the young generation. Eden allocation and garbage collection is also really cheap. It&#8217;s treated kind of like stack allocation; creating a new object usually just requires bumping the pointer that defines the end of Eden. Garbage collection is also simple; live objects get copied out to the first survivor, and then the Eden pointer gets zeroed back to the start of the heap. Trash doesn&#8217;t need to be explicitly zeroed out, so deallocation is &#8220;free&#8221;. Note that this efficiency is true only for small objects; larger objects (megabytes) are allocated in a different and more expensive way directly to the old&nbsp;generation.</p>
<p>Garbage collection happens when Eden fills up. This might sound bad since young GCs are stop-the-world and happen erratically, but young generation <span class="caps">GC</span> time is proportional to the number of live young objects, which is usually small compared to the amount of trash. Concurrent <span class="caps">GC</span> can happen in the background, avoiding that nasty stop-the-world pause, but only for the old generation, and it&#8217;s not perfect. More on this&nbsp;later.</p>
<h3>Garbage Collector&nbsp;Tuning</h3>
<p>Attila iterates multiple times that the more memory you can give the young generation, the better, since allocation and deallocation is so cheap. I think he then backpedaled a bit though, because really big young generations can lead to long pauses while the live objects are copied around. What you want is a young generation big enough to hold active and tenuring objects, and for long-lived objects to quickly tenure and reach the old generation. However, you also don&#8217;t want survivors to get forced to the old generation early by memory pressure on the young&nbsp;generation.</p>
<p>With this in mind, lets talk about the different garbage collectors available in HotSpot. They can be divided into two categories, throughput and&nbsp;latency:</p>
<ul>
<li>Throughput: scheduled to run when the <span class="caps">JVM</span> runs out of memory. Stop-the-world operation.<ul>
<li>SerialGC: Single-threaded garbage collector. Sun probably wrote this one first, and it&#8217;s around for legacy&nbsp;reasons.</li>
<li>ParallelGC and ParallelOldGC: Multi-threaded garbage collectors. ParallelOldGC is actually better than ParallelGC since it cleans both the young and old generations (rather than just the young&nbsp;generation).</li>
</ul>
</li>
<li>Latency: scheduled to run periodically by the <span class="caps">JVM</span> when it has spare cycles. Can still result in stop-the-world if the <span class="caps">GC</span> can&#8217;t clean fast enough and memory runs out.<ul>
<li>ConcMarkSweepGC (<span class="caps">CMS</span>): Concurrent and tries to be &#8220;low pause&#8221;. <span class="caps">CMS</span> has a number of caveats though. It kicks in when allocated memory passes a threshold, meaning you need to overprovision memory by 25-33% to give it a buffer to allocate with while it cleans. It also doesn&#8217;t compact memory, so you can get fragmentation that leads to stop-the-world pauses. As stated earlier, it also only cleans the old generation, and uses a throughput collector for the young&nbsp;generation.</li>
<li><span class="caps">G1GC</span>: undocumented black magic that Attila had no experience with, and explicitly didn&#8217;t not cover in his presentation. I found <a href="http://www.oracle.com/technetwork/java/javase/tech/g1-intro-jsp-135488.html">this link to the Oracle documentation</a> though, it&#8217;s supposed to be a better replacement for&nbsp;<span class="caps">CMS</span>.</li>
</ul>
</li>
</ul>
<p>There are a lot of options here, so Attila breaks it down into some simple&nbsp;heuristics.</p>
<ol>
<li>Look for ways to reduce the application&#8217;s memory consumption. Less memory pressure means less garbage&nbsp;collection.</li>
<li>Try a throughput collector with adaptive sizing turned on, which lets the <span class="caps">JVM</span> figure out the best sizes for the different generations. If this works, great! <code>-XX:+PrintHeapAtGC</code> can be helpful&nbsp;here.</li>
<li>Next, try ConcMarkSweepGC. <code>-verbosegc</code> and <code>-XX:+PrintGcDetails</code> are useful here. This is a situation where you might adjust the young generation to reduce the pause from young gen <span class="caps">GC</span> time, but also make sure that the survivor regions aren&#8217;t filling&nbsp;up.</li>
</ol>
<p>If you&#8217;re interested, a quick search turned up two links to official Oracle documentation for the HotSpot 1.4.2 garbage collectors. It&#8217;s a bit dated, but I think most of it still&nbsp;applies.</p>
<ul>
<li><a href="http://java.sun.com/docs/hotspot/gc1.4.2/">Tuning Garbage Collection with the 1.4.2 Java Virtual&nbsp;Machine</a></li>
<li><a href="http://java.sun.com/docs/hotspot/gc1.4.2/faq.html"><span class="caps">FAQ</span> about Garbage Collection in the Hotspot Java Virtual&nbsp;Machine</a></li>
</ul>
<h3>Programming&nbsp;Anecdotes</h3>
<p>These are miscellaneous tips pulled from the talk. Most of them boil down to using less memory, which is a much better solution than trying to tune the <span class="caps">GC</span>. There were some out-of-the-box solutions, and some Twitter-specific things&nbsp;too.</p>
<ul>
<li>Get used to profiling your code, especially third party libraries.<ul>
<li>For instance, Guava sucks up <span class="caps">2KB</span> each time you make a map by default to handle concurrency&nbsp;cases.</li>
<li>Don&#8217;t use Thrift&#8217;s <span class="caps">RPC</span> classes as your domain objects, deserialize rather than keeping them around. They have extra overhead compared to normal&nbsp;objects.</li>
</ul>
</li>
<li>Normalize your data when possible. If some data is shared between multiple objects, have them all point to the same instance instead of each having their own&nbsp;copy.</li>
<li>
<p>Beware of worker thread pools sharing connections to many storage servers; this can result in <code>m * n</code> cached connection objects if you&#8217;re using thread&nbsp;locals.</p>
<ul>
<li>It&#8217;s better to instead use fewer threads and asynchronous&nbsp;I/O.</li>
<li>Also, don&#8217;t be afraid of just creating a new object on demand. It&#8217;s cheap in Eden, just a single pointer&nbsp;bump!</li>
<li>Synchronized objects are another alternative to thread&nbsp;locals.</li>
</ul>
</li>
<li>
<p>If you&#8217;re having trouble packing it all into one <span class="caps">JVM</span>, try using&nbsp;multiple!</p>
</li>
<li>Twitter had a service that would have a terrible <span class="caps">GC</span> pause every three days. Solution: just bounce the machine after less than three&nbsp;days.</li>
<li>Don&#8217;t write your own memory manager, and stop if you find yourself doing something ugly with byte buffers.<ul>
<li>The one notable exception is if you need it for a very limited and simple case. Cassandra has its own slab allocator with fixed size slabs that are flushed to disk when memory is full. This is so simple that it&#8217;s&nbsp;okay.</li>
</ul>
</li>
<li>Oracle told Twitter that the garbage collector isn&#8217;t actually complained about that much, since people have figured out how to engineer around&nbsp;it.</li>
<li>You should never have to call the garbage collector yourself in&nbsp;code.</li>
</ul>
<h3>Conclusion</h3>
<p>This is far from a complete discussion on memory management in Java, but it&#8217;s got some easy and immediately applicable findings, and I hope these notes help direct further reading. I want to give Bill Pugh&#8217;s super detailed <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/">&#8220;The Java Memory Model&#8221;</a> a read, and there are a few Java performance tuning books on my Amazon wishlist&nbsp;too.</p>
<p>Again, leave a comment if something is unclear or incorrect, and I&#8217;ll do my best to fix it&nbsp;up.</p>
<!-- Hyde::Article::End -->

			
			</div>
		</div>


	
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'umbrant'; // required: replace example with your forum shortname

    // The following are highly recommended additional parameters. Remove the slashes in front to use.
    var disqus_identifier = '/blog/2012/twitter_jvm_tuning.html';
    var disqus_url = 'http://www.umbrant.com/blog/2012/twitter_jvm_tuning.html';
    //var disqus_developer = 1;

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>




						</div>
						<!-- end #content -->

						<div id="sidebar">
	<div id="logo">
		<h1><a href="/">umbrant</a></h1>
	</div>
	<div>
		<p>My name is Andrew Wang. I'm a CS PhD student at UC Berkeley working in distributed systems.</p>
	</div>
	<div id="menu">
		<ul>
			<li><a href="/">Home</a></li>
			<li><a href="/about.html">About</a></li>
			<li><a href="/research.html">Research</a></li>
			<li><a href="/contact.html">Contact</a></li>
		</ul>
	</div>
	<ul>
		<li>
		<h2>Recent Posts</h2>
		<ul>
			
				
			
				

					
					
						
					
						
						<li><a href="/blog/2012/twitter_jvm_tuning.html">JVM Performance Tuning (notes)</a></li>
						
					
						
						<li><a href="/blog/2012/year_in_review_2011_personal.html">Year in review: 2011 (personal)</a></li>
						
					
						
						<li><a href="/blog/2012/year_in_review_2011_professional.html">Year in review: 2011 (professional)</a></li>
						
					
						
						<li><a href="/blog/2012/haystack_review.html">Paper review: Facebook Haystack</a></li>
						
					
						
						<li><a href="/blog/2011/relational_cloud_and_database_scalability.html">Paper review: Relational Cloud, Database Scalability</a></li>
						
					
				
			
				
			
				
			
				
			
				
			
		</ul>
		</li>
		<li>
		<h2>Archive</h2>
		<ul>
			
			
			
			
				
				
				<li><a href="/blog/2012/2012.html">2012</a></li>
				
				
				
				
				
				
				
				<li><a href="/blog/2011/2011.html">2011</a></li>
				
				
				
				
			
			
			
			
			
			
			
			
			
			
		</ul>
		</li>
	</ul>
</div>

						<!-- end #sidebar -->

									<div id="footer">
				<p>Copyright &copy; Andrew Wang, umbrant.com</p>
				<p>Licensed under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a></p>
				<br/>
				<p><a href="http://feeds.feedburner.com/UmbrantBlog"><img src="/media/images/feed-icon-14x14.png" alt="feed"/>&#160; Subscribe to my feed</a></p>
			</div>

						<!-- end #footer -->

					</div>
				</div>
			</div>
			<!-- end #page -->
		</div>
	 </body>
 </html>

 