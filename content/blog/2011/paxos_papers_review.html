{% extends "_post.html" %}

{%load webdesign %}

{%hyde
    title: "Paper review: Paxos, Paxos, and Chubby"
    created: 2011-09-22 14:53:00
    draft: True
%}

{% block article %}

{%article%}

{% excerpt %}

I'm combining my paper reviews this time, since they are pretty closely coupled:

* "Paxos Made Simple", Lamport, 2001
* "Paxos Made Practical", Mazieres, 2007
* "The Chubby Lock Service for Loosely-coupled Distributed Systems", Burrows, 2006

{%endexcerpt%}

## Paxos Made Simple

Paxos is a distributed consensus algorithm. At it's essence, it's a quorum-based fault-tolerant way of arriving at a single consistent value among a group of machines. This can be used to do leader election (consensus on who's the master), or synchronous strong consistency (replicating writes in a distributed database). In the case of Chubby, it's used for both: determining who holds a lock (leader election), and serving strongly consistent small files.

Paxos has two basic types of actors:

* *Proposers* are nodes that are trying to get a value accepted as the "true" value during a round of consensus. Normally, which node is the proposer is pretty stable, and only changes on failure.
* *Acceptors* receive proposals from proposers, and vote as part of the quorum. They act as replicas for the global state of the system.

Paxos also has two rounds of communication. Here I'm showing the basic version. There are four types of messages here: propose, promise, accept, and accepted.

1. Propose
	* The proposer sends a *proposal* to all the acceptors in the system, and waits for a reply. This proposal is tagged with a round number **N**, which has to increase each time this proposer makes a new proposal. A common thing to do is make this number out of the IP address and some local counter, so they are globally unique.
	* The acceptors *promise* to accept the proposal if the proposal's **N** is the highest **N** they've seen from any proposer. A promise indicates that the acceptor will ignore any proposal with a lower number. This is so there's a total ordering on proposals; we don't care which proposer wins, we just want one to win. 
1. Accept
	* If the proposer hears back from a quorum of acceptors, it sends out *accept* requests to the quorum with the value it wants to set.
	* If the acceptor hasn't promised to a higher proposal number in the meantime, it tells the proposer it *accepted*.

If the proposer gets back a quorum of accepted messages, then it commits. At this point, it can further replicate the value to other nodes, or respond to the client that the operation worked. It's normal for all nodes in the system to in fact fulfill the roles of both proposer and acceptor as needed.

There is one detail that prevents future proposers from changing the value when issuing a higher number proposal. In the first round, the acceptor promise also sends the number and value of the highest number proposal they've accepted. Then, the proposer uses the value of the highest number proposal it gets back when it commits in the accept round.

## Paxos Made Practical

## Chubby Lock Service

This is an engineering industry paper from Google, always interesting reads. The basic idea of Chubby is running Paxos on a small *cell* of five machines to solve consensus problems. One of the five machines in the cell acts as the master, and runs Paxos to decide writes. Reads are all served from the master. It's accessed essential as a Unix-like filesystem which has the property of atomic whole-file writes. This means it's great for storing things small bits of metadata that need to be kept very consistent, or used as a better version of DNS (no worrying about stale entries and TTLs). 

{%endarticle%}

{% endblock %}
